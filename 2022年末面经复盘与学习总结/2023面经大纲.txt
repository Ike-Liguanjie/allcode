
1.go基础相关
1. Slice切片和数组的区别（高频）
    1.长度：切片是不定长度，可以随着数据增多而扩容。数组是固定长度，无法扩容。
    2.赋值：切片是类型引用，内存地址不发生改变。数组是拷贝一个全新数组，内存地址发生改变。
    3.传参：切片作为参数传递，在函数内改变会影响到上层。数组作为参数传递如果不传指针，则无法影响到原参数。
    注意点1：切片因为是引用，在使用一个极大数组的小切片时，会导致原数组内存不释放，引起内存泄露，正确做法是拷贝一个新切片出来，释放原数组内存。
    注意点2：切片扩容规则是：当新容量比原有容量的2倍还大，那将直接扩容到新容量。当长度小于1024，每次扩容为原来的2倍，大于的时候扩容原来的1.25倍。
    注意点3：切片不具备线程安全，如果在多线程操作切片的时候需要使用sync.Mutex互斥锁或者channel管道来控制。
2. 如何避免panic
    panic会导致程序异常退出，recover方法可以捕获panic错误，使用defer关键字可以保证程序在发生panic错误的时候运行recover方法
    多层defer是后进先出，最后进入的异常最先报，然后一层层上报，每一层错误码记录清晰，通过日志定位问题所在
3. goroutine详解
    go语言中的协程，可以通过go关键字起一个goroutine来运行方法（这里引申出进程、线程、协程的定义）
    需要注意的是，go语言中main方法本身就是一个主goroutine，其他所有的协程都是子goroutine，main方法结束后，其他所有子goroutine都会一起结束。
    goroutine可以通过runtime.Gosched()主动交出控制器，来运行其他goroutine。
    这里讲到go中goroutine的调度策略，即GMP模型。
4. channel详解  》缓冲区
    定义：通俗的理解，channel是一个特定类型的管道，不同的goroutine可以通过这个管道进行数据传递。
    管道遵循先进先出的原则，通过->箭头操作符来进行存取，在channel为空时候读取会被block，满了存放会被block。
    当channel被关闭的时候，无法再继续往channel中发送数据，但是可以接收。
    通过select可以处理对通道的发送和接收。(select case 可以理解为switch)

5. Gc算法（三色标记法）（超高频）
    golangGC的历程：V1.3使用标记-清除(Mark-Sweep)，V1.5开始三色标记法，V1.8是三色标记法+混合屏障
    golangv1.5版本之后开始使用的三色标记法，在这之前使用的是标记-清除(Mark-Sweep)
    缺点：不支持并发，操作过程中需要暂停程序，暂停时间较长

    三色标记法：
    1.从根对象出发，将当前可达对象标记为灰色
    2.遍历灰色对象，将当前可达对象标记为灰色，自身标记为黑色
    3.重复步骤2
    4.清除所有白色对象
    缺点：会出现错标和漏标的情况，因为在并发情况下，垃圾回收线程和业务逻辑一起运行，在本来标记为灰色的对象遗弃，会导致这种浮动垃圾存货到下一次GC。
    漏标是本来应该在下一轮扫描的灰色对象被标记为黑色，导致下一轮未遍历该灰色对象，将其子对象给回收。

    插入写屏障：在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)，注意栈上不启用插入屏障
    缺点：扫描结束后需要对栈上rescan，耗费时间。
    删除写屏障：被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。
    缺点：回收精度低，会导致本应该清除的垃圾存活到下一次GC。

    用来降低STW的混合写屏障：
    1.GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，
    2.GC期间，任何在栈上创建的新对象，均为黑色。
    3.被删除的对象标记为灰色。
    4.被添加的对象标记为灰色。

6. GMP模型（超高频！！！）
    G是goroutine，golang中的协程，包含当前执行的M指针和sched相关寄存器地址。
    M是machine，golang中的线程，包含g0和tls本地线程池，g0负责G调度切换，线程池储存了当前运行的G。
    P是process，golang中的调度器，包含G队列，G头和G尾以及队列长度。
    M通过P来运行G，因为P的存在，M无需绑定和记录G的状态，每个G必须绑定在P上才可以执行，P相当于是G的CPU，P给M提供内存分配和可执行G的信息。
    P的调度策略：主动调度、被动调度、正常调度和抢占调度。
        主动调度：用户通过执行runtime.Gosched让当前G让出执行权，进入队列等待下次执行。
        被动调度：G被阻塞导致无法调度，底层会走进gopark方法，最终通过其他G执行goready来恢复阻塞，将G重新放入队列中等待下次执行。
        正常调度：G正常结束运行并死亡，继续执行下一个G。
        抢占调度：全局G monitor会轮询监控所有P，当前G执行时间过久且P资源紧张的时候会解除这个G与P的绑定关系，让其他G来执行，同时将G重新放入队列中等待下次执行。
    P如何寻找可执行的G：
        G分为两个队列，全局队列和P的本地队列。P执行的时候优先寻找本地队列，本地队列为空就去全局队列拉取。
        当全局队列也为空的时候就去网络轮询器network poller(golang的I/O调度模型)中寻找。
        前面条件都不满足的时候就会触发work stealing，即从其他P的本地队列中获取一半G来减缓其他P的压力。
        注意：P每调度执行61次G，都会去执行一个全局队列中的G，并拉取一个全局队列的G到本地队列中。若当前本地队列已满，则会返还一半的G到全局队列里。
    P如何执行G：
        1.更新G的状态信息
        2.绑定G与M的关系
        3.更新P的调度次数
        4.调用gogo方法，从g0切换到g并执行，执行完毕后调用m_call切换为g0

7. Map并发安全
    同slice一样，Map的并发操作也是不安全的，可以通过sync.Mutex互斥锁或者sync.Map来实现并发安全。
    map是引用类型
    map遍历是无序的
    map是非线程安全的
    map的哈希冲突解决方式是链表法
    map的扩容不是一定会新增空间，也有可能是只是做了内存整理
    map的迁移是逐步进行的，在每次赋值时，会做至少一次迁移工作
    map中删除key，有可能导致出现很多空的kv，这会导致迁移操作，如果可以避免，尽量避免
8. profile工具
    profile工具是来检测程序性能的，自带的有net/http/pprof
    我没用过这些

2.mysql相关
1. select Sql语句的执行过程
    1.客户端与服务端建立连接，通过TCP
    2.查询缓存，如果命中直接返回结果。(8.0版本删除了查询缓存这一步)
    3.解析器解析SQL语句，查询是否存在语法错误。
    4.执行SQL语句，优化器对语句进行优化处理，比如选择哪一种索引，优化条件命中联合索引等。
    5.上述步骤都是在server层，执行器执行sql语句通过调用引擎存储层的API来提取数据，返回给客户端。
2. mysql默认存储引擎，区别（InnoDB，MyISAM）
    InnoDB是mysql的默认引擎(5版本以后)，采用MVCC作为版本控制，同时实现了4个隔离级别，默认的隔离级别是可重复读。
    InnDB的主键索引是簇族索引，采用B+树结构，且实现了行锁来保证并发。
    Myisam不支持事务和行锁，导致崩溃后无法恢复数据。

3. 索引数据结构，聚簇索引和非聚簇索引介绍，B+树跟B树相比的优点（超高频）
4. 默认的隔离级别，一共有哪些，解决了什么问题
    默认的隔离级别是可重复读。隔离级别一共4个，分别是读未提交、读已提交、可重复读和串行化。
    分别解决了脏读、不可重复读和幻读。
5. 事务的特性
    1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。
        也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。
　　 2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
　　 3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。
　　 4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。
6. MVCC
    Mutil-Version Concurrency Control，MySQL的多版本并发控制，InnoDB引擎下的。
    每个聚簇索引下会有额外两个隐藏字段，trx_id和roll_pointer。
    trx_id记录了更新操作的事务ID，roll_pointer记录了undo log的地址指针。
    每个事务会创建一个read view，里面有4个字段。
    creator_trx_id：创建当前Read View所对应的事务ID
    m_ids：所有当前未提交事务的事务ID，也就是活跃事务的事务id列表
    min_trx_id：m_ids里最小的事务id值
    max_trx_id：InnoDB 需要分配给下一个事务的事务ID值（事务 ID 是累计递增分配的，所以后面分配的事务ID一定会比前面的大！）
    每次读取会去比较trx_id与creator_trx_id的大小，小于自己就直接读，大于自己就去历史的undo log里去读。
7. ACID
    就是事务的4个特性原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），通过MVCC来保证的。
8. explain中索引的类型
    * consts：单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
    * ref：使用普通的索引
    * range：对索引进行范围检索
    * Index：索引物理文件全扫，速度非常慢。
9. 什么是最左匹配原则和联合索引
    由多个字段建立的索引就叫做联合索引或多列索引
    最左前缀匹配原则顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。
    最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配
    比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
    =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

3.Redis相关
1. 基础数据类型
    1.动态字符串SDS
    2.链表
    3.字典
    4.跳跃表
    5.整数集合
    6.压缩列表
2. 跳跃表的实现
3. 缓存穿透、缓存击穿、缓存雪崩都是什么，怎么预防
    缓存穿透：请求的数据在缓存和数据库当中都没有，这样请求会不断落在数据库上，仿佛缓存不存在一样，并发高了容易把数据库打死。
    解决办法一是对请求过来的数据做校验防止恶意攻击，二是数据库不存在的数据也会给一个表示没有数据的缓存，设置一个过期时间，过期了才再次请求。判断数据是否存在可以用布隆过滤器

    缓存击穿：某个访问量较大的热点数据过期，请求直接打到数据库上，导致数据库直接被打死。
    解决办法是对于热点数据设置永不过期。

    缓存雪崩：大量的key在某个时间点刚好同时过期，这时候所有的请求都直接打在了数据库上，导致数据库被打死。
    解决办法是在批量添加key的时候设置随机过期时间，避免同一时间大量的key一起失效。
4. 单线程还是多线程（6.0版本开始支持多线程处理I/O读写操作）》单线程为什么这么快（内存上操作、key/value的数据结构、I/O多路复用、单线程避免了线程切换开销）
5. 集群模式  高可用
6. 事务
7. 发布与订阅
8. 数据持久化
    redis提供两种数据持久化，RDB和AOF
    RDB，快照方式将内存数据持久化到硬盘。save同步阻塞进行保存，bgsave异步fork子进程出来进行保存。(默认方式)
    AOF，命令方式将每次的写命令储存起来，文件过大时可以用rewriteaof进行文件重写。always永远同步写操作，everysec每秒异步操作一次。

    比较：RDB快照文件比AOF要小，恢复数据速度快。但在持久化期间写入的数据RDB不会保存，如果出现问题会丢失这部分数据。
        AOF文件写入性能高，且数据最多丢失1秒。

4.k8s、docker相关
1. 基础概念，有哪些组件，起什么作用
2. 如何监听pod状态，pod内容器是否相互隔离
3. Docker与虚拟机的区别

5.网络相关
1. Tcp的三次握手，四次挥手
2. Tcp与Udp的区别
3. time_await和time_close，大量出现怎么解决
4. http和http2的区别，http3了解么
5. Https的加密、证书相关
6. Websocket详解》稳定性、兼容性

6.操作系统相关
1. 协程与线程的区别
2. 查看端口命令  lsof -i:8888或者netstat -tunlp
3. 查看资源命令 top
4. I/O多路复用
5. 悲观锁、乐观锁，应用场景简单说下

7.ES相关
1. 倒排索引
2. 怎么保证数据一致性
3. 如何降低压力
4. 日志存储时长是多少

8.算法相关
1. 基础数据结构复习：数组、链表、哈希表、树
2. LRU算法（超高频！！！）
3. 两个有序列表合成一个有序列表（双指针）（高频）
4. 括号匹配
5. 实现有序map（带左右节点的哈希表）
6. 反转单链表
7. 快排
8. 寻找第K大元素（最大堆）
9. 二分查找（有序才可二分）
10. 限流算法
11. 二叉树（前序、中序、后序） PS：我的弱项，需要加强
    * 给前序、中序推后序和给中序、后序推前序
    * 翻转二叉树
    * 二叉树是否是完全二叉树
    * 二叉树是否对称


9.杂项
1. 读扩散和写扩散
2. 不要用共享内存来通信，而是用通信来共享内存（单机都可以，分布式要利用中间件来通信共享）channel也是遵循这个原则
3. Nginx负载均衡
4. 浏览器键入地址后到加载内容一共发生了什么
5. 日志工具（可作为拓展，目前用的是kibana）
6. go与node的区别

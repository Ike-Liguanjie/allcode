
1.go基础相关
1. Slice切片和数组的区别（高频）
    1.长度：切片是不定长度，可以随着数据增多而扩容。数组是固定长度，无法扩容。
    2.赋值：切片是类型引用，内存地址不发生改变。数组是拷贝一个全新数组，内存地址发生改变。
    3.传参：切片作为参数传递，在函数内改变会影响到上层。数组作为参数传递如果不传指针，则无法影响到原参数。
    注意点1：切片因为是引用，在使用一个极大数组的小切片时，会导致原数组内存不释放，引起内存泄露，正确做法是拷贝一个新切片出来，释放原数组内存。
    注意点2：切片扩容规则是：当新容量比原有容量的2倍还大，那将直接扩容到新容量。当长度小于1024，每次扩容为原来的2倍，大于的时候扩容原来的1.25倍。
    注意点3：切片不具备线程安全，如果在多线程操作切片的时候需要使用sync.Mutex互斥锁或者channel管道来控制。
2. 如何避免panic
    panic会导致程序异常退出，recover方法可以捕获panic错误，使用defer关键字可以保证程序在发生panic错误的时候运行recover方法
    多层defer是后进先出，最后进入的异常最先报，然后一层层上报，每一层错误码记录清晰，通过日志定位问题所在
3. goroutine详解
    go语言中的协程，可以通过go关键字起一个goroutine来运行方法（这里引申出进程、线程、协程的定义）
    需要注意的是，go语言中main方法本身就是一个主goroutine，其他所有的协程都是子goroutine，main方法结束后，其他所有子goroutine都会一起结束。
    goroutine可以通过runtime.Gosched()主动交出控制器，来运行其他goroutine。
    这里讲到go中goroutine的调度策略，即GMP模型。
4. channel详解  》缓冲区
    定义：通俗的理解，channel是一个特定类型的管道，不同的goroutine可以通过这个管道进行数据传递。
    管道遵循先进先出的原则，通过->箭头操作符来进行存取，在channel为空时候读取会被block，满了存放会被block。
    当channel被关闭的时候，无法再继续往channel中发送数据，但是可以接收。
    通过select可以处理对通道的发送和接收。(select case 可以理解为switch)

5. Gc算法（三色标记法）（超高频）
    golangGC的历程：V1.3使用标记-清除(Mark-Sweep)，V1.5开始三色标记法，V1.8是三色标记法+混合屏障
    golangv1.5版本之后开始使用的三色标记法，在这之前使用的是标记-清除(Mark-Sweep)
    缺点：不支持并发，操作过程中需要暂停程序，暂停时间较长

    三色标记法：
    1.从根对象出发，将当前可达对象标记为灰色
    2.遍历灰色对象，将当前可达对象标记为灰色，自身标记为黑色
    3.重复步骤2
    4.清除所有白色对象
    缺点：会出现错标和漏标的情况，因为在并发情况下，垃圾回收线程和业务逻辑一起运行，在本来标记为灰色的对象遗弃，会导致这种浮动垃圾存货到下一次GC。
    漏标是本来应该在下一轮扫描的灰色对象被标记为黑色，导致下一轮未遍历该灰色对象，将其子对象给回收。

    插入写屏障：在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)，注意栈上不启用插入屏障
    缺点：扫描结束后需要对栈上rescan，耗费时间。
    删除写屏障：被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。
    缺点：回收精度低，会导致本应该清除的垃圾存活到下一次GC。

    用来降低STW的混合写屏障：
    1.GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，
    2.GC期间，任何在栈上创建的新对象，均为黑色。
    3.被删除的对象标记为灰色。
    4.被添加的对象标记为灰色。

6. GMP模型（超高频！！！）
7. Map并发安全
8. profile工具

2.mysql相关
1. Sql语句的执行过程
2. mysql默认存储引擎，区别（InnoDB，MyISAM）
3. 索引数据结构，聚簇索引和非聚簇索引介绍，B+树跟B树相比的优点（超高频）
4. 默认的隔离级别，一共有哪些，解决了什么问题
5. 事务的特性
6. MVCC
7. ACID
8. explain中索引的类型
    * consts：单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
    * ref：使用普通的索引
    * range：对索引进行范围检索
    * Index：索引物理文件全扫，速度非常慢。

3.Redis相关
1. 基础数据类型
2. 跳跃表的实现
3. 缓存穿透、缓存击穿、缓存雪崩都是什么，怎么预防
4. 单线程还是多线程（6.0版本开始支持多线程处理I/O读写操作）》单线程为什么这么快（内存上操作、key/value的数据结构、I/O多路复用、单线程避免了线程切换开销）
5. 集群模式  高可用
6. 事务
7. 发布与订阅

4.k8s、docker相关
1. 基础概念，有哪些组件，起什么作用
2. 如何监听pod状态，pod内容器是否相互隔离
3. Docker与虚拟机的区别

5.网络相关
1. Tcp的三次握手，四次挥手
2. Tcp与Udp的区别
3. time_await和time_close，大量出现怎么解决
4. http和http2的区别，http3了解么
5. Https的加密、证书相关
6. Websocket详解》稳定性、兼容性

6.操作系统相关
1. 协程与线程的区别
2. 查看端口命令  lsof -i:8888或者netstat -tunlp
3. 查看资源命令 top
4. I/O多路复用
5. 悲观锁、乐观锁，应用场景简单说下

7.ES相关
1. 倒排索引
2. 怎么保证数据一致性
3. 如何降低压力
4. 日志存储时长是多少

8.算法相关
1. 基础数据结构复习：数组、链表、哈希表、树
2. LRU算法（超高频！！！）
3. 两个有序列表合成一个有序列表（双指针）（高频）
4. 括号匹配
5. 实现有序map（带左右节点的哈希表）
6. 反转单链表
7. 快排
8. 寻找第K大元素（最大堆）
9. 二分查找（有序才可二分）
10. 限流算法
11. 二叉树（前序、中序、后序） PS：我的弱项，需要加强
    * 给前序、中序推后序和给中序、后序推前序
    * 翻转二叉树
    * 二叉树是否是完全二叉树
    * 二叉树是否对称


9.杂项
1. 读扩散和写扩散
2. 不要用共享内存来通信，而是用通信来共享内存（单机都可以，分布式要利用中间件来通信共享）channel也是遵循这个原则
3. Nginx负载均衡
4. 浏览器键入地址后到加载内容一共发生了什么
5. 日志工具（可作为拓展，目前用的是kibana）
6. go与node的区别

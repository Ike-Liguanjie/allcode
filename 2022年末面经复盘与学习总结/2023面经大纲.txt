
1.go基础相关
1. Slice切片和数组的区别（高频）
    1.长度：切片是不定长度，可以随着数据增多而扩容。数组是固定长度，无法扩容。
    2.赋值：切片是类型引用，内存地址不发生改变。数组是拷贝一个全新数组，内存地址发生改变。
    3.传参：切片作为参数传递，在函数内改变会影响到上层。数组作为参数传递如果不传指针，则无法影响到原参数。
    注意点1：切片因为是引用，在使用一个极大数组的小切片时，会导致原数组内存不释放，引起内存泄露，正确做法是拷贝一个新切片出来，释放原数组内存。
    注意点2：切片扩容规则是：当新容量比原有容量的2倍还大，那将直接扩容到新容量。当长度小于1024，每次扩容为原来的2倍，大于的时候扩容原来的1.25倍。
    注意点3：切片不具备线程安全，如果在多线程操作切片的时候需要使用sync.Mutex互斥锁或者channel管道来控制。
2. 如何避免panic
    panic会导致程序异常退出，recover方法可以捕获panic错误，使用defer关键字可以保证程序在发生panic错误的时候运行recover方法
    多层defer是后进先出，最后进入的异常最先报，然后一层层上报，每一层错误码记录清晰，通过日志定位问题所在
3. goroutine详解
    go语言中的协程，可以通过go关键字起一个goroutine来运行方法（这里引申出进程、线程、协程的定义）
    需要注意的是，go语言中main方法本身就是一个主goroutine，其他所有的协程都是子goroutine，main方法结束后，其他所有子goroutine都会一起结束。
    goroutine可以通过runtime.Gosched()主动交出控制器，来运行其他goroutine。
    这里讲到go中goroutine的调度策略，即GMP模型。
4. channel详解  》缓冲区
    定义：通俗的理解，channel是一个特定类型的管道，不同的goroutine可以通过这个管道进行数据传递。
    管道遵循先进先出的原则，通过->箭头操作符来进行存取，在channel为空时候读取会被block，满了存放会被block。
    当channel被关闭的时候，无法再继续往channel中发送数据，但是可以接收。
    通过select可以处理对通道的发送和接收。(select case 可以理解为switch)

5. Gc算法（三色标记法）（超高频）
    golangGC的历程：V1.3使用标记-清除(Mark-Sweep)，V1.5开始三色标记法，V1.8是三色标记法+混合屏障
    golangv1.5版本之后开始使用的三色标记法，在这之前使用的是标记-清除(Mark-Sweep)
    缺点：不支持并发，操作过程中需要暂停程序，暂停时间较长

    三色标记法：
    1.从根对象出发，将当前可达对象标记为灰色
    2.遍历灰色对象，将当前可达对象标记为灰色，自身标记为黑色
    3.重复步骤2
    4.清除所有白色对象
    缺点：会出现错标和漏标的情况，因为在并发情况下，垃圾回收线程和业务逻辑一起运行，在本来标记为灰色的对象遗弃，会导致这种浮动垃圾存货到下一次GC。
    漏标是本来应该在下一轮扫描的灰色对象被标记为黑色，导致下一轮未遍历该灰色对象，将其子对象给回收。

    插入写屏障：在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)，注意栈上不启用插入屏障
    缺点：扫描结束后需要对栈上rescan，耗费时间。
    删除写屏障：被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。
    缺点：回收精度低，会导致本应该清除的垃圾存活到下一次GC。

    用来降低STW的混合写屏障：
    1.GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，
    2.GC期间，任何在栈上创建的新对象，均为黑色。
    3.被删除的对象标记为灰色。
    4.被添加的对象标记为灰色。

6. GMP模型（超高频！！！）
    G是goroutine，golang中的协程，包含当前执行的M指针和sched相关寄存器地址。
    M是machine，golang中的线程，包含g0和tls本地线程池，g0负责G调度切换，线程池储存了当前运行的G。
    P是process，golang中的调度器，包含G队列，G头和G尾以及队列长度。
    M通过P来运行G，因为P的存在，M无需绑定和记录G的状态，每个G必须绑定在P上才可以执行，P相当于是G的CPU，P给M提供内存分配和可执行G的信息。
    P的调度策略：主动调度、被动调度、正常调度和抢占调度。
        主动调度：用户通过执行runtime.Gosched让当前G让出执行权，进入队列等待下次执行。
        被动调度：G被阻塞导致无法调度，底层会走进gopark方法，最终通过其他G执行goready来恢复阻塞，将G重新放入队列中等待下次执行。
        正常调度：G正常结束运行并死亡，继续执行下一个G。
        抢占调度：全局G monitor会轮询监控所有P，当前G执行时间过久且P资源紧张的时候会解除这个G与P的绑定关系，让其他G来执行，同时将G重新放入队列中等待下次执行。
    P如何寻找可执行的G：
        G分为两个队列，全局队列和P的本地队列。P执行的时候优先寻找本地队列，本地队列为空就去全局队列拉取。
        当全局队列也为空的时候就去网络轮询器network poller(golang的I/O调度模型)中寻找。
        前面条件都不满足的时候就会触发work stealing，即从其他P的本地队列中获取一半G来减缓其他P的压力。
        注意：P每调度执行61次G，都会去执行一个全局队列中的G，并拉取一个全局队列的G到本地队列中。若当前本地队列已满，则会返还一半的G到全局队列里。
    P如何执行G：
        1.更新G的状态信息
        2.绑定G与M的关系
        3.更新P的调度次数
        4.调用gogo方法，从g0切换到g并执行，执行完毕后调用m_call切换为g0

7. Map并发安全
    同slice一样，Map的并发操作也是不安全的，可以通过sync.Mutex互斥锁或者sync.Map来实现并发安全。
    map是引用类型
    map遍历是无序的
    map是非线程安全的
    map的哈希冲突解决方式是链表法
    map的扩容不是一定会新增空间，也有可能是只是做了内存整理
    map的迁移是逐步进行的，在每次赋值时，会做至少一次迁移工作
    map中删除key，有可能导致出现很多空的kv，这会导致迁移操作，如果可以避免，尽量避免
8. profile工具
    profile工具是来检测程序性能的，自带的有net/http/pprof
    我没用过这些

2.mysql相关
1. Sql语句的执行过程
2. mysql默认存储引擎，区别（InnoDB，MyISAM）
3. 索引数据结构，聚簇索引和非聚簇索引介绍，B+树跟B树相比的优点（超高频）
4. 默认的隔离级别，一共有哪些，解决了什么问题
5. 事务的特性
6. MVCC
7. ACID
8. explain中索引的类型
    * consts：单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
    * ref：使用普通的索引
    * range：对索引进行范围检索
    * Index：索引物理文件全扫，速度非常慢。

3.Redis相关
1. 基础数据类型
2. 跳跃表的实现
3. 缓存穿透、缓存击穿、缓存雪崩都是什么，怎么预防
4. 单线程还是多线程（6.0版本开始支持多线程处理I/O读写操作）》单线程为什么这么快（内存上操作、key/value的数据结构、I/O多路复用、单线程避免了线程切换开销）
5. 集群模式  高可用
6. 事务
7. 发布与订阅

4.k8s、docker相关
1. 基础概念，有哪些组件，起什么作用
2. 如何监听pod状态，pod内容器是否相互隔离
3. Docker与虚拟机的区别

5.网络相关
1. Tcp的三次握手，四次挥手
2. Tcp与Udp的区别
3. time_await和time_close，大量出现怎么解决
4. http和http2的区别，http3了解么
5. Https的加密、证书相关
6. Websocket详解》稳定性、兼容性

6.操作系统相关
1. 协程与线程的区别
2. 查看端口命令  lsof -i:8888或者netstat -tunlp
3. 查看资源命令 top
4. I/O多路复用
5. 悲观锁、乐观锁，应用场景简单说下

7.ES相关
1. 倒排索引
2. 怎么保证数据一致性
3. 如何降低压力
4. 日志存储时长是多少

8.算法相关
1. 基础数据结构复习：数组、链表、哈希表、树
2. LRU算法（超高频！！！）
3. 两个有序列表合成一个有序列表（双指针）（高频）
4. 括号匹配
5. 实现有序map（带左右节点的哈希表）
6. 反转单链表
7. 快排
8. 寻找第K大元素（最大堆）
9. 二分查找（有序才可二分）
10. 限流算法
11. 二叉树（前序、中序、后序） PS：我的弱项，需要加强
    * 给前序、中序推后序和给中序、后序推前序
    * 翻转二叉树
    * 二叉树是否是完全二叉树
    * 二叉树是否对称


9.杂项
1. 读扩散和写扩散
2. 不要用共享内存来通信，而是用通信来共享内存（单机都可以，分布式要利用中间件来通信共享）channel也是遵循这个原则
3. Nginx负载均衡
4. 浏览器键入地址后到加载内容一共发生了什么
5. 日志工具（可作为拓展，目前用的是kibana）
6. go与node的区别

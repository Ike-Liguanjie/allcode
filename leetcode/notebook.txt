刷题心得（其实是看书心得），记录自己的思考与体会
PS:顺序按照自己所看的书的顺序

基础算法：
一、滑动窗口和双指针
滑动窗口顾名思义，是维护一个区间从头滑动到尾部，因为此时双指针就分别在区间的两端，这里滑动窗口又分为固定长度和不固定长度。
1.固定长度窗口
2.不定长度窗口

固定长度窗口较为简单，一般用于求解在k个长度的区间内最大值、平均值、最小值等等。
此时只要先初始化一个以0为左端点，k为长度的区间，求出题目所需要的答案res，然后循环的往区间内添加右端点+1的数字，移除左端点的数字，同时更新左右端点和res即可。

而不定长度窗口的问题要更为复杂，双指针的概念也更为突出。这个时候要求的就不是k长度的区间，而是满足题目要求的最大或最小区间。
此时的左右端点移动要根据题目来决定，并且结合某些题目，需要维护一个哈希表来方便我们处理。
比如求出最长的不含有重复字母的字串，哈希表用来存放右指针指向的字母，当有重复字母出现时，就要停止移动右指针，转而移动左指针，直到重复的字母被移出哈希表。
在这个不断移动的过程中去更新我们最大长度的res，直到右指针走到数组的尾部，我们的答案也就出来了。

总结：解题的关键在于根据题目精准找到左右指针移动的条件，必要时候需要维护一个哈希表来方便我们去做一些判断。


二、数组和字符串
因为数组和字符串都可以通过索引来查找到，所以对于索引的利用是一个重点。

数组是一种数据结构，其中能用到的算法太多，不好总结，本书内所用到的也普遍是一些简单的技巧。
字符串与数组类似，不过有一种字符串匹配算法：KMP，对于目前的我来说用处不大，所以并未深究。

总结：对于数字很多都可以利用双指针来解决，字符串也类似。


三、哈希表
哈希表可以通过键值直接访问到内存中的元素，因此哈希表查找的复杂度为O(1)

哈希表类的题目难点在于，如何通过巧妙的设立键值来解决问题。
比如给定一个包含n个单词的数组，将这些单词按照异位词来分组并返回。
由于异位词所用到的字母只是顺序不同，所以可以通过把字母排序后的值作为键值来存放数据，这样最后生成的哈希表就是按照异位词分组了的。

总结：根据问题的关键来设置哈希表的键值，有些题目可以和双指针来结合解决。


四、数组类算法
同二，书中的例子可以通过双指针，二分查找来解决。

总结：数组类的题目解决方法很多，指针对撞、二分查找、排序、动态规划等都可以解决。


五、链表
链表也是一种数据结构，其中又可分为单链表和双链表。
1.单链表，每一个node节点的next指向下一个node节点
2.双链接，每一个node节点的prev指向上一个node节点，next指向下一个节点

链表类题目模板较少，比如翻转链表，回文链表、判断单链表是否有环、找出单链表的环的节点、找出两个单链表相交的节点等。
链表题目基本都可以通过双指针来解决，这里双指针的用法不是上面哈希表中的左右端点，也不是数组类算法中二分查找那种指针对撞，而是快慢指针。
一般情况下会设立两个指针，起点都在head，慢指针每移动一步，快指针会移动两步，由此来解决题目中的要求。

总结：快慢指着是解决大部分链表问题的关键，翻转链表则是用好中间变量。


六、查找表类算法
查找类问题，一般是查找是否存在和查找对应关系，不同的题目对应的数据结构也不一样。
例如找出两个数组的交集，这时候可以通过建立哈希集合来判断是否存在重复的数字。
如果找出的交集只能满足最少的那个列表的元素，这个时候就要通过哈希映射来解决。
对于两数之和、三数之和、四数之和则可以通过哈希表和指针对撞来解决。

总结：根据题目的需求建立数据结构，哈希表因为O(1)的查找复杂度是解决相关问题的首选。


七、二叉树
二叉树是一种树型的数据结构，二叉树的遍历分为前序遍历、中序遍历和后序遍历。
1.前序遍历，按照先访问根节点，后遍历左子树，再遍历右子树的顺序进行遍历
2.中序遍历，按照先遍历左子树，后访问根节点，再遍历右子树的顺序进行遍历
3.后序遍历，按照先遍历左子树，后遍历右子树，再访问根节点的顺序进行遍历

提到树就不得不提到动态规划、深度优先搜索(DFS)、广度优先搜索(BFS)，这三类算法和递归有着不可分割的关系。
不过本书中并未用到DFS和BFS，而且有专门的书讲解动态规划、BFS和DFS，所以这里就不做更多赘述。

总结：简单的二叉树问题，可以通过动态规划完美解决。


八、队列和栈
队列是一种先入先出的数据结构，栈是一种先入后出的数据结构。

本书中关于队列和BFS以及栈和DFS的题目我并未深入了解（其实是看不懂），因为后续有专门的书介绍，所以打算略过回头在看。

总结：了解队列和栈的特性即可，至此基础算法的书已经全部看完了，从下一接开始进阶算法。


进阶算法：
九、贪心算法
之前就看到说算法分为分治、贪心、动态规划和回溯，其中贪心、动态规划和回溯比较相似。
1.回溯算法需要记录每一个步骤、每一个选择，用于回答所有具体解的问题；
2.动态规划需要记录的是每一个步骤、所有选择的汇总值（最大、最小或者计数）；
3.贪心算法由于适用的问题，每一个步骤只有一种选择，一般而言只需要记录与当前步骤相关的变量的值。

使用贪心算法的最关键的一个点是，从局部最优解可以得到全局最优解。
贪心算法是一宗思想，它意味着在每一步都选择当前能看到的最大利益直到结束，此时的局部最优解就是全局最优解。

总结：做了本书中贪心的所有题目，还是没有找到那种融会贯通的感觉，给我的感觉就是，贪心算法是需要你先从每个f(x)中去总结出规律，然后根据这个规律去贪。


十、动态规划精讲（一）

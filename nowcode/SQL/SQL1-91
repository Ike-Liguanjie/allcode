前言：本来想像LeetCode那样一题一个文件，多答案+题解的形式来搞的。
    但是看了sql的题目有些就是一句话，不值得单独一个文件，所以还是全部放到一个文件里吧。
    很多题目的缺失是因为题库没这道题，不知道为什么。


# 1.难度：入门 降序首条，这里直接用order by + limit
SELECT * FROM employees ORDER BY hire_date DESC LIMIT 1;

# 2.难度：简单 降序第三条，同第一题，不过limit要给两个参数，相当于index和length
SELECT * FROM employees ORDER BY hire_date DESC LIMIT 2,1;

# 3.难度：中等 左连接、右连接和内连接的用法
SELECT s.*, d.dept_no FROM salaries s INNER JOIN dept_manager d ON (s.emp_no=d.emp_no) ORDER BY s.emp_no ASC;

# 4.难度：简单 同上一题
SELECT e.last_name, e.first_name, d.dept_no FROM dept_emp d LEFT JOIN employees e ON (d.emp_no=e.emp_no);

# 5.难度：中等 同上一题
SELECT e.last_name, e.first_name, d.dept_no FROM dept_emp d RIGHT JOIN employees e ON (d.emp_no=e.emp_no);

# 7.难度：简单 having的用法，一般统计筛选用
SELECT emp_no, COUNT(emp_no) as t FROM salaries GROUP BY emp_no HAVING t>15;

# 8.难度：简单 分组+排序
SELECT salary FROM salaries GROUP BY salary ORDER BY salary DESC;

# 10.难度：简单 外连接的变种
SELECT e.emp_no FROM employees e LEFT JOIN dept_manager d ON (e.emp_no=d.emp_no) WHERE d.dept_no IS NULL;

# 11.难度：中等 同上一题
SELECT d1.emp_no, d2.emp_no manage FROM dept_emp d1 LEFT JOIN dept_manager d2 ON (d1.dept_no=d2.dept_no) WHERE d1.emp_no!=d2.emp_no;

# 12.难度：困难 先建立临时表取得部门工资最高数量，再内连接工资表，查出最高工资者
SELECT t.dept_no, max(s.emp_no), t.maxSalary FROM (SELECT d.dept_no, max(s.salary) as maxSalary FROM dept_emp d, salaries s WHERE d.emp_no=s.emp_no GROUP BY d.dept_no) t INNER JOIN salaries s ON (s.salary=t.maxSalary) GROUP BY t.dept_no ORDER BY t.dept_no;

# 15.难度：简单 where条件的运用
SELECT * FROM employees WHERE (emp_no%2)=1 AND last_name!='Mary' ORDER BY hire_date DESC;

# 16.难度：中等 sql函数avg的运用
SELECT t.title, AVG(s.salary) as salary FROM titles t, salaries s WHERE t.emp_no=s.emp_no GROUP BY t.title ORDER BY salary;

# 17.难度：简单 降序第二条，跟第一二题同理
SELECT emp_no, salary FROM salaries ORDER BY salary DESC LIMIT 1,1;

# 18.难度：较难 找出薪水第二高的人，关键点在于不能使用order by，思路就是max，第一遍找最大来排除，第二遍找最大来锁定
SELECT e.emp_no, s.salary, e.last_name, e.first_name FROM employees e, salaries s WHERE e.emp_no=s.emp_no AND s.salary=(SELECT max(salary) FROM salaries WHERE salary!=(SELECT max(salary) FROM salaries));

# 19.难度：中等 员工表，部门表和中间表，查询用两次left join
SELECT e.last_name, e.first_name, d.dept_name FROM employees e LEFT JOIN dept_emp de ON (e.emp_no=de.emp_no) LEFT JOIN departments d ON (de.dept_no=d.dept_no);

# 21.难度：困难 思路是创建两张临时表，员工表先内连接一张在职员工当前薪水表，再内连接一张员工入职的薪水表，最后升序即可
SELECT e.emp_no, (t1.salary-t2.salary) AS growth FROM employees e INNER JOIN (SELECT emp_no, salary FROM salaries WHERE to_date='9999-01-01') t1 ON (t1.emp_no=e.emp_no) LEFT JOIN (SELECT s.emp_no, s.salary FROM salaries s, (SELECT emp_no, min(to_date) AS to_date FROM salaries GROUP BY emp_no) t WHERE s.emp_no=t.emp_no AND s.to_date=t.to_date) t2 ON (t2.emp_no=e.emp_no) ORDER BY growth ASC;

# 22.难度：中等 跨表查询，利用count计数，group by分组
SELECT d.*, COUNT(s.emp_no) FROM departments d, dept_emp, salaries s WHERE d.dept_no=dept_emp.dept_no AND dept_emp.emp_no=s.emp_no GROUP BY d.dept_no ORDER BY d.dept_no;

# 23.难度：较难 跨表查询，依然是利用count计数去重
SELECT s1.emp_no, s1.salary, (SELECT COUNT(DISTINCT s2.salary) FROM salaries s2 WHERE s2.salary >= s1.salary) t_rank FROM salaries s1 ORDER BY t_rank, s1.emp_no;

# 24.难度：较难 利用左连接找出非管理者
SELECT t.dept_no, t.emp_no, t.salary FROM (SELECT d1.emp_no, d1.dept_no, s.salary, d2.to_date FROM dept_emp d1 LEFT JOIN salaries s ON (d1.emp_no=s.emp_no) LEFT JOIN dept_manager d2 ON (d1.emp_no=d2.emp_no)) t WHERE t.to_date IS NULL AND t.salary IS NOT NULL;

# 25.难度：困难 左连接+1，然后通过where筛选
SELECT d.emp_no, t.manager_no, s.salary, t.manager_salary FROM dept_emp d LEFT JOIN (SELECT d1.dept_no, d1.emp_no manager_no, s1.salary manager_salary FROM dept_manager d1, salaries s1 WHERE d1.emp_no=s1.emp_no) ON (t.dept_no=d.dept_no) LEFT JOIN salaries s ON (d.emp_no=s.emp_no) WHERE s.salary>t.manager_salary;

# 26.难度：困难 group by的双字段分组，然后order by排序
SELECT d.dept_no, de.dept_name, t.title, COUNT(t.title) t FROM titles t, dept_emp d, departments de WHERE d.emp_no=t.emp_no AND d.dept_no=de.dept_no GROUP BY d.dept_no, t.title ORDER BY d.dept_no;

# 28.难度：困难 条件具有优先级，要保证类型的电影数量>5，而且简介包含robot
SELECT c.name, COUNT(f.film_id) FROM film_category fc, category c, film f WHERE fc.film_id=f.film_id AND c.category_id=fc.category_id AND f.description LIKE '%robot%' AND c.category_id IN (SELECT category_id FROM film_category GROUP BY category_id HAVING COUNT(film_id)>=5);

# 29.难度：中等 左链接筛选出分类名字为空的
SELECT f.film_id, f.title FROM film f LEFT JOIN film_category fc ON (f.film_id=fc.film_id) LEFT JOIN category c ON (fc.category_id=c.category_id) WHERE c.name IS NULL;

# 30.难度：中等 子查询找出分类id，然后搜索对应电影
SELECT f.title, f.description FROM film f, film_category fc, (SELECT category_id FROM category WHERE name='Action') t WHERE f.film_id=fc.film_id AND fc.category_id=t.category_id;

# 32.难度：简单 concat用法，拼接字符串
SELECT CONCAT(last_name,' ', first_name) FROM employees;

# 33.难度：中等 create table语句
CREATE TABLE actor (actor_id smallint(5) NOT NULL, first_name varchar(45) NOT NULL, last_name varchar(45) NOT NULL, last_update date NOT NULL, PRIMARY KEY (actor_id));

# 34.难度：简单 insert into语句
INSERT INTO actor (actor_id, first_name, last_name, last_update) VALUES (1, 'PENELOPE', 'GUINESS', '2006-02-15 12:34:33'), (2, 'NICK', 'WAHLBERG', '2006-02-15 12:34:33');

# 35.难度：中等 insert ignore语句
INSERT IGNORE actor (actor_id, first_name, last_name, last_update) value (3, 'ED', 'CHASE', '2006-02-15 12:34:33');

# 36.难度：中等 创建数据库后插入数据
一。先创建再插入
CREATE TABLE actor_name (first_name varchar(45) NOT NULL, last_name varchar(45) NOT NULL);
INSERT INTO actor_name SELECT first_name, last_name FROM actor;
二。创建的同时插入
CREATE TABLE IF NOT EXISTS actor_name (first_name varchar(45) NOT NULL, last_name varchar(45) NOT NULL) SELECT first_name,last_name FROM actor;

# 37.难度：中等 创建索引
一。alert
ALTER TABLE actor ADD UNIQUE uniq_idx_firstname (first_name);
ALTER TABLE actor ADD INDEX idx_lastname (last_name);
二。create
CREATE UNIQUE INDEX uniq_idx_firstname on actor (first_name);
CREATE INDEX idx_lastname ON actor (last_name);

# 38.难度：中等 创建视图
CREATE VIEW actor_name_view(first_name_v, last_name_v) AS SELECT first_name, last_name FROM actor WITH CHECK OPTION;

# 39.难度：中等 force强制使用索引
SELECT * FROM salaries FORCE INDEX (idx_emp_no) WHERE emp_no='10005';

# 40.难度：中等 alert增加字段
ALTER TABLE actor ADD create_date datetime NOT NULL DEFAULT '2020-10-01 00:00:00' AFTER last_update;
